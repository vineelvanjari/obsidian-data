# ğŸš€ DSA Multiverse Canvas â€“ Session 01

Today: 6 Problems Solved âœ…

---

# 1ï¸âƒ£ Largest Element in an Array

Standard Name: **Largest Element in an Array / Find Maximum in Array**

ğŸ”— Platforms:

- LeetCode (Closest â€“ Kth Largest): [https://leetcode.com/problems/kth-largest-element-in-an-array/](https://leetcode.com/problems/kth-largest-element-in-an-array/)
    
- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/largest-element-in-array4009/1](https://www.geeksforgeeks.org/problems/largest-element-in-array4009/1)
    
- CodeChef: [https://www.codechef.com/practice/course/arrays/ARRAYS/problems/UWCOI20A](https://www.codechef.com/practice/course/arrays/ARRAYS/problems/UWCOI20A)
    

### ğŸ§  Your Version

```cpp
int findMax(int a[], int n) {
    int max = a[0];
    for(int i = 1; i < n; i++) {
        if(a[i] > max)
            max = a[i];
    }
    return max;
}
```

### ğŸš€ Best Version (Same â€“ Already Optimal)

Time Complexity: O(n)  
Space Complexity: O(1)

## Example: [8,2,10,-3,15,12]
### ğŸ§  Your Version Explanation

- Assume first element (8) is maximum.
    
- Traverse entire array from index 0.
    
- Compare every element with current max.
    
- If greater, update max.
    
- Final max becomes 15.
    

Flow: 8 â†’ compare 2 â†’ no change 8 â†’ compare 10 â†’ update to 10 10 â†’ compare -3 â†’ no change 10 â†’ compare 15 â†’ update to 15 15 â†’ compare 12 â†’ no change Result = 15


# 2ï¸âƒ£ Find First and Last Occurrence of K

Standard Name: **Find First and Last Position of Element in Sorted Array**

ğŸ”— Platforms:

- LeetCode: [https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
    
- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/first-and-last-occurrences-of-x3116/1](https://www.geeksforgeeks.org/problems/first-and-last-occurrences-of-x3116/1)
    
- Coding Ninjas: [https://www.codingninjas.com/studio/problems/find-first-and-last-position-of-element-in-sorted-array_839724](https://www.codingninjas.com/studio/problems/find-first-and-last-position-of-element-in-sorted-array_839724)
    

### ğŸ§  Your Version (Linear Search)

```cpp
vector<int> findFirstLast(int a[], int n, int k) {
    int first = -1, last = -1;
    for(int i = 0; i < n; i++) {
        if(a[i] == k) {
            if(first == -1)
                first = i;
            last = i;
        }
    }
    return {first, last};
}
```

### ğŸš€ Best Version (Binary Search â€“ Sorted Array)

```cpp
int firstOcc(vector<int>& nums, int target) {
    int l = 0, r = nums.size() - 1, ans = -1;
    while(l <= r) {
        int mid = l + (r - l)/2;
        if(nums[mid] >= target) {
            if(nums[mid] == target) ans = mid;
            r = mid - 1;
        } else l = mid + 1;
    }
    return ans;
}

int lastOcc(vector<int>& nums, int target) {
    int l = 0, r = nums.size() - 1, ans = -1;
    while(l <= r) {
        int mid = l + (r - l)/2;
        if(nums[mid] <= target) {
            if(nums[mid] == target) ans = mid;
            l = mid + 1;
        } else r = mid - 1;
    }
    return ans;
}
```

Time Complexity: O(log n)
## Example: [2,10,3,15,3,3,15,7], k = 3

### ğŸ§  Your Version (Linear Search)

- Initialize first = -1, last = -1.
    
- Traverse array.
    
- When element equals k:
    
    - If first not set, set first.
        
    - Always update last.
        

Indexes of 3: 2, 4, 5 Result: first = 2, last = 5 Time Complexity: O(n)

### ğŸš€ Best Version (Binary Search â€“ Sorted Required)

- Use modified binary search.
    
- For first occurrence: Move left when match found.
    
- For last occurrence: Move right when match found. Time Complexity: O(log n)
    

Note: Binary search works only if array is sorted.

---

# 3ï¸âƒ£ Max Consecutive Ones

Standard Name: **Max Consecutive Ones**

ğŸ”— Platforms:

- LeetCode: [https://leetcode.com/problems/max-consecutive-ones/](https://leetcode.com/problems/max-consecutive-ones/)
    
- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/max-consecutive-one/1](https://www.geeksforgeeks.org/problems/max-consecutive-one/1)
    

### ğŸ§  Your Version

```cpp
int longestOnes(int a[], int n) {
    int count = 0, maxCount = 0;
    for(int i = 0; i < n; i++) {
        if(a[i] == 1) {
            count++;
            maxCount = max(maxCount, count);
        } else {
            count = 0;
        }
    }
    return maxCount;
}
```

### ğŸš€ Best Version (Same â€“ Already Optimal)

Time Complexity: O(n)  
Space Complexity: O(1)

## Example: [0,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,0,0]

### ğŸ§  Your Version

- Maintain count and maxCount.
    
- If element is 1 â†’ increment count.
    
- If 0 â†’ reset count to 0.
    
- Update maxCount continuously.
    

Longest streak = 4

### ğŸš€ Best Version

Already optimal single pass solution. Cannot reduce further since each element must be checked.

---

# 4ï¸âƒ£ Second Largest Element

Standard Name: **Second Largest Element in an Array**

ğŸ”— Platforms:

- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/second-largest3735/1](https://www.geeksforgeeks.org/problems/second-largest3735/1)
    
- CodeChef: [https://www.codechef.com/practice/course/arrays/ARRAYS/problems/LARGESECOND](https://www.codechef.com/practice/course/arrays/ARRAYS/problems/LARGESECOND)
    
- HackerRank: [https://www.hackerrank.com/challenges/find-second-maximum-number-in-a-list](https://www.hackerrank.com/challenges/find-second-maximum-number-in-a-list)
    
- HackerEarth: [https://www.hackerearth.com/problem/algorithm/large-but-not-largest-1/](https://www.hackerearth.com/problem/algorithm/large-but-not-largest-1/)
    

### ğŸ§  Your Version

```cpp
int secondLargest(int a[], int n) {
    int max1 = INT_MIN, max2 = INT_MIN;
    for(int i = 0; i < n; i++) {
        if(a[i] > max1) {
            max2 = max1;
            max1 = a[i];
        } else if( a[i] < max1 && a[i] > max2) {
            max2 = a[i];
        }
    }
    return max2;
}
```

### ğŸš€ Best Version (Same â€“ Optimal Single Pass)

Time Complexity: O(n)  
Space Complexity: O(1)


## Example: [5,3,15,12,15,20]

### ğŸ§  Your Version

- Maintain two variables: max1 and max2.
    
- If element > max1: max2 = max1 max1 = element
    
- Else if element > max2 and not equal to max1: update max2
    

Traversal: 5 â†’ max1=5 3 â†’ max2=3 15 â†’ max1=15, max2=5 12 â†’ max2=12 15 â†’ ignored duplicate 20 â†’ max1=20, max2=15

Result = 15

### ğŸš€ Best Version

Same logic. Single pass is optimal. Sorting would cost O(n log n), so this is better.

---

# 5ï¸âƒ£ Row Sum of Matrix

Standard Name: **Row Sum in a Matrix**

ğŸ”— Platforms:

- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/row-sum-in-a-matrix/1](https://www.geeksforgeeks.org/problems/row-sum-in-a-matrix/1)
    

### ğŸ§  Your Version

```cpp
void rowSum(int mat[][4], int n, int m) {
    for(int i = 0; i < n; i++) {
        int sum = 0;
        for(int j = 0; j < m; j++) {
            sum += mat[i][j];
        }
        cout << sum << endl;
    }
}
```

### ğŸš€ Best Version

Already optimal â€“ requires full traversal.  
Time Complexity: O(n Ã— m)

## Example: { {5,0,1,7}, {8,3,5,-2}, {-4,1,3,0} }

### ğŸ§  Your Version

- Outer loop for rows.
    
- Inner loop for columns.
    
- Reset sum for every row.
    
- Add each element of row.
    

Row sums: Row1 = 13 Row2 = 14 Row3 = 0

### ğŸš€ Best Version

Full traversal required. Time Complexity = O(n Ã— m) Optimal already.


---

# 6ï¸âƒ£ Swap Major and Minor Diagonals

Standard Name: **Swap Major and Minor Diagonals of a Square Matrix**

ğŸ”— Platforms:

- GeeksforGeeks: [https://www.geeksforgeeks.org/problems/swap-major-and-minor-diagonals-of-a-square-matrix/1](https://www.geeksforgeeks.org/problems/swap-major-and-minor-diagonals-of-a-square-matrix/1)
    

### ğŸ§  Your Version

```cpp
void swapDiagonals(int mat[][5], int n) {
    for(int i = 0; i < n; i++) {
        swap(mat[i][i], mat[i][n-i-1]);
    }
}
```

### ğŸš€ Best Version

Same logic â€“ single loop diagonal swap is optimal.  
Time Complexity: O(n)  
Space Complexity: O(1)

## Example (5Ã—5 matrix)

Major diagonal indices: (0,0), (1,1), (2,2)... Minor diagonal indices: (0,n-1), (1,n-2)...

### ğŸ§  Your Version

- Loop i from 0 to n-1.
    
- Swap mat[i][i] with mat[i][n-i-1].
    
- Only one loop needed.
    

### ğŸš€ Best Version

Same approach. Only diagonal elements touched. Time Complexity = O(n) Space Complexity = O(1)



---
